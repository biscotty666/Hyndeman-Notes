# Toolbox

# Tidy Forecasting Workflow

-   Data preparation (tidy)

-   Plot the data (visualize)

-   Define a model (specify)

-   Train the model (estimate)

-   Check the model (evaluate)

-   Produce forecasts (forecast)

```{r}
library(fpp3)
```

## Model GDP per capita over time

### Prepare the relevant variable

```{r}
gdppc <- global_economy |>
  mutate(GDP_per_capita = GDP / Population)
```

### Plot the data (look at one country)

```{r}
gdppc |>
  filter(Country == "Sweden") |>
  autoplot(GDP_per_capita) +
  labs(y = "$US", title = "GDP per capita for Sweden")
```

### Define the model. In this example, use a trend model from TSLM

```{r}
TSLM(GDP_per_capita ~ trend()) -> trend_model
```

### Train the model

```{r}
fit <- gdppc |>
  model(trend_model = trend_model)
```

```{r}
fit
```

### Check model performance

### Produce forecasts

```{r}
fit |> forecast(h = "3 years")
```

.mean contains the point forecast, GDP_per_capita contains the distribution.

```{r}
fit |>
  forecast(h = "3 years") |>
  filter(Country == "Sweden") |>
  autoplot(gdppc) +
  labs(y = "$US", title = "GDP per capita for Sweden")
```

# Some simple methods

-   Mean method: future values equal to historical mean

-   Naive method: forecast equal to last observation

-   Seaonal naive method: forecast equal to last observed value from same season

-   Drift method: Naive but forecasts can increase or decrease over time

## Example: beer production

```{r}
train <- aus_production |>
  filter_index("1992 Q1" ~ "2006 Q4")
beer_fit <- train |>
  model(
    Mean = MEAN(Beer),
    `Naive` = NAIVE(Beer),
    `Seasonal naive` = SNAIVE(Beer)
  )
beer_fc <- beer_fit |> forecast(h = 14)
beer_fc |>
  autoplot(train, level = NULL) +
  autolayer(
    filter_index(aus_production, "2007 Q1" ~ .),
    colour = 'black'
  ) +
  labs(
    y = "Megalitres",
    title = "Forecasts for quarterly beer production"
  ) +
  guides(colour = guide_legend(title = "Forecast"))
```

## Example Google stock price

```{r}
# Re-index based on trading days
google_stock <- gafa_stock |>
  filter(Symbol == "GOOG", year(Date) >= 2015) |>
  mutate(day = row_number()) |>
  update_tsibble(index = day, regular = TRUE)
# Filter the year of interest
google_2015 <- google_stock |> filter(year(Date) == 2015)
# Fit the models
google_fit <- google_2015 |>
  model(
    Mean = MEAN(Close),
    `Naïve` = NAIVE(Close),
    Drift = NAIVE(Close ~ drift())
  )
# Produce forecasts for the trading days in January 2016
google_jan_2016 <- google_stock |>
  filter(yearmonth(Date) == yearmonth("2016 Jan"))
google_fc <- google_fit |>
  forecast(new_data = google_jan_2016)
# Plot the forecasts
google_fc |>
  autoplot(google_2015, level = NULL) +
  autolayer(google_jan_2016, Close, colour = "black") +
  labs(y = "$US",
       title = "Google daily closing stock prices",
       subtitle = "(Jan 2015 - Jan 2016)") +
  guides(colour = guide_legend(title = "Forecast"))
```

# Fitted values and residuals

```{r}
augment(beer_fit)
```

There are three new columns added to the original data:

-   `.fitted` contains the fitted values;
-   `.resid` contains the residuals;
-   `.innov` contains the “innovation residuals” which, in this case, are identical to the regular residuals

# Residual diagnostics

A good forecast method will have these properties

1.  The innovation residuals are uncorrelated. If there are correlations
    between innovation residuals, then there is information left in the
    residuals which should be used in computing forecasts.
2.  The innovation residuals have zero mean. If they have a mean other than zero, then the forecasts are biased.
3.  The innovation residuals have constant variance. This is known as “homoscedasticity”.
4.  The innovation residuals are normally distributed.

Not all are necessary, and models satisfying these may still be able to be improved.

```{r}
autoplot(google_2015, Close) +
  labs(y = "$US",
       title = "Google daily closing stock prices in 2015")
```

```{r}
aug <- google_2015 |>
  model(NAIVE(Close)) |>
  augment()
autoplot(aug, .innov) +
  labs(y = "$US",
       title = "Residuals from the naïve method")
```

```{r}
aug |>
  ggplot(aes(x = .innov)) +
  geom_histogram() +
  labs(title = "Histogram of residuals")
```

```{r}
aug |>
  ACF(.innov) |>
  autoplot() +
  labs(title = "Residuals from the naïve method")
```

```{r}
google_2015 |>
  model(NAIVE(Close)) |>
  gg_tsresiduals()
```

## Portmanteau tests for autocorrelation
